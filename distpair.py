#!/usr/bin/env python3
# coding: utf-8

# Importing Packages and Modules
import argparse
import csv
import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
import logging
import numpy as np
import os
from math import sqrt
from matplotlib.ticker import FuncFormatter

# Function definitions
# Parameters configuration
def get_options():
    parser = argparse.ArgumentParser(prog='distpair', description='Visualization of pairdist generated by gmx.')
    parser.add_argument('-i', '--input', required=True, help='Specify the pairdist input file (.xvg)')
    parser.add_argument('-n', '--ref', required=True, type=int, help='Number of reference positions')
    parser.add_argument('-m', '--sel', required=True, type=int, help='Number of selection positions')
    parser.add_argument('-o', '--outdir', default='./output_distplot/', help='Specify the output directory')
    parser.add_argument('-b', '--bin', default=5, type=int, help='Specify the number of bins')
    parser.add_argument('-k', '--topk', default=5, type=int, help='Specify the top k interested pairs based on bin 1')
    parser.add_argument('-s', '--sym', default=True, type=bool, help='Whether or not ref and sel are the same group')
    parser.add_argument('-by', '--sortby', default=1, type=int, help='Primary bin for sorting')

    # subparser for the query
    subparsers = parser.add_subparsers(dest='subparser', help='sub-command help')
    parser_a = subparsers.add_parser('query', help='label of the query, e.g., r1s2')
    parser_a.add_argument('--label', required=True, help='label of the query, e.g., r1s2')
    parser_a.add_argument('--rmax', required=False, type=int, default=20)
    parser_a.add_argument('--smax', required=False, type=int, default=20)
    parser_a.add_argument('--threshold', required=False, default=0.6)

    args = parser.parse_args()
    return args

# Function to query a record by label
def query_by_labels(labels):
    for i in range(0,len(hist_data)):
        if hist_data[i][0] in labels:
            print(hist_data[i])

# Function to convert frequency to percentage
def to_percent(y, position):
    s = '%1.0f' % (100 * (y / time))
    if mpl.rcParams['text.usetex'] is True:
        return s + r'$\%$'
    else:
        return s + '%'

# Heatmap Function
def heatmap(title, hist_data, num_of_bin, time, bins_labels, outdir):
    T = list(map(list, zip(*hist_data)))
    fig = plt.figure(figsize=(100,20))
    ax = fig.add_subplot(111)
    cax = ax.matshow(T[1:], interpolation='nearest', aspect='auto', cmap='rainbow')
    ax.set_xticks(np.arange(0,len(hist_data),1000))
    xticklabels = [hist_data[i][0] for i in np.arange(0,len(hist_data),1000)] #TODO: zero
    ax.set_xticklabels(xticklabels, rotation=90, fontsize=50)
    # ax.set_xticklabels([hist_data[i][0] for i in np.arange(0, len(hist_data), 1000)], rotation=45, fontsize=20)
    ax.xaxis.set_ticks_position('bottom')
    ax.set_yticks(np.arange(0, num_of_bin))
    ax.set_yticklabels(bins_labels, fontsize=80)
    ax.tick_params(axis='y', which='both', labelsize=80)
    cbar = fig.colorbar(cax)
    cbar.set_ticks(np.arange(0, time, time/10))
    cbar.set_ticklabels(['%1.0f%%' % (100 * freq / time) for freq in np.arange(0, time, time/10)])
    cbar.ax.tick_params(labelsize=80)
    ax.set_title('Distance distribution per bin', fontsize=80)
    plt.savefig('{}/{}_heatmap.png'.format(outdir, title))
    plt.show()

# Plot the general histogram
def plot_top_k(time, top_k, df, bins, num_of_bin, hist_data, formatter, outdir, title):
    colors = ['purple', 'green', 'blue', 'brown', 'red', 'orange', 'grey', 'darkgreen', 'darkblue', 'indigo', 'forestgreen',
         'black', 'maroon']
    top_k_label = [row[0] for row in top_k]
    top_k_data = [df[i].values for i in top_k_label]
    fontsize = 20
    x = np.arange(0, time, 40)

    for i in range(0, len(top_k)):
        fig = plt.figure(figsize=(25,5))
        ax1 = fig.add_subplot(1,2,1)
        ax2 = fig.add_subplot(1,2,1, sharex=ax1, frameon=False)
        ax3 = fig.add_subplot(1,2,2)
        plt.subplots_adjust(left=0.2, wspace=0.5, top=0.8)
        for j in range(0, len(top_k)):
            if j == i:  # highlight
                ax1.plot(top_k_data[j], c=colors[j%len(colors)], label=top_k_label[j],  linewidth=3)
                highlight = top_k_label[j]
            else:
                ax1.plot(top_k_data[j], c=colors[j%len(colors)], label=top_k_label[j],  linewidth=1, ls='--', alpha=0.4)

        ax1.set_xlim(0, time - 1)
        ax1.set_xticks(x)
        ax1.set_xlabel('Frame', fontsize=fontsize)
        ax1.set_ylabel('Distance (nm)', fontsize=fontsize)
        ax1.set_ylim(bins[0], bins[num_of_bin])
        for i in np.arange(0, num_of_bin, 2):
            ax1.axhspan(bins[i], bins[i+1], alpha=0.3, color='grey')
        ax1.legend(fontsize=15, loc='upper left', bbox_to_anchor=(-0.4,1))
        ax1.tick_params(axis='both', which='both', labelsize=fontsize)
        ax2.tick_params(axis='both', which='both', labelsize=fontsize)

        pair = df[highlight]
        n, bins, patches = plt.hist(pair, bins=bins, ec='black', alpha=0.5, color='lightblue')
        ax3.set_xlabel('Distance (nm)', fontsize=fontsize)
        ax3.set_xlim(0, bins[num_of_bin] + 0.5)
        ax3.set_xticks(np.arange(0, bins[num_of_bin] + 0.5, 0.5))
        ax3.set_ylabel('Percentage', fontsize=fontsize)
        ax3.set_ylim(0, top_k[0][1] + time * 0.1)
        ax3.set_yticks(np.arange(0, top_k[0][1] + time * 0.1, time/10))
        ax3.yaxis.set_major_formatter(formatter)
        ax3.tick_params(axis='both', which='both', labelsize=fontsize)
        rects = ax3.patches
        for rect, bin_label in zip(rects, ['Bin%d' % (i+1) for i in range(len(rects))]):
            height = rect.get_height()
            if (height > 0):
                ax3.text(rect.get_x() + rect.get_width() / 2, height, bin_label, ha='center', va='bottom', fontsize=16)

        ax2.yaxis.tick_right()
        ax2.yaxis.set_label_position('right')
        ax2.set_ylim(0, num_of_bin)
        ax2.set_yticks(np.arange(0.5, num_of_bin, 1))
        ylabels = ['%1.0f%% in Bin' % ((100 * item / time)) for item in n]
        ylabels = [item + str(index + 1) for index, item in enumerate(ylabels)]
        ax2.set_yticklabels(ylabels, fontsize=fontsize)
        ax2.tick_params(axis='y', which='both', length=0)
        plt.savefig('{}/{}_{}.png'.format(outdir, title, highlight))
        plt.show()


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
logger.info("scripting starts...")

# get arguments from command line
args = get_options()
rawfilepath = args.input
outdir = args.outdir
cleanfilepath = outdir + 'cleaned_distpair.xvg'
n_by_n = args.sym
num_of_bin = args.bin
k = args.topk
m = args.sel
n = args.ref

# create the output directory
try:
    os.stat(outdir)
except:
    os.mkdir(outdir)

logger.info("cleaning the data...")
# Clean the data
# Skip the comments starting with '#' or '@'.
with open(rawfilepath, 'r') as raw, open(cleanfilepath, 'w') as clean:
    for line in raw:
        if not line.startswith('#') and not line.startswith('@'):
            clean.write(line.strip() + '\n')
    raw.close()
    clean.close()

logger.info("loading the data, it may take sometime depending on the size of input...")
# Load the Data Frame
# This step may take some time depending on the input size
df = pd.read_csv(cleanfilepath, header=None, index_col=0, sep='\s+', comment='#')
dropped = False
time = df.shape[0]
max = df.values.max()
logger.debug(max)
min = df[df > 0].dropna(axis=1).values.min() #TODO: special case may exist when there is only a few nan in a colomn

logger.info("Data loaded as a data frame.")

# Create bins
bins = np.linspace(min, max, num_of_bin + 1)
# label of bins
bins_labels = ['Bin{:d}'.format(i) for i in range(1, num_of_bin + 1)]

logger.debug(bins)
logger.debug(bins_labels)

# Generate Dataframe Header
# ### Generate all the headers
df_header = ['r{}s{}'.format(r, s) for s in range(1, n+1) for r in range(1, m+1)]
logger.debug(df_header[0:10])

df.columns = df_header
logger.info('Data frame infomation as follow:')
logger.info(df.info())

df.to_csv('labeledd_output.csv', sep=',')

# Generate headers for the column to be dropped
# For N x N pairs, the self reflective pair, (e.g., r1s1, r2s2) and same pair, (e.g., r1s2 and r2s1) need to be dropped.
if n_by_n is True and not dropped:
    n = int(sqrt(df.shape[1]))
    df_drop_header = ['r{}s{}'.format(r, s) for s in range(1, n + 1) for r in range(s, n + 1)]
    logger.debug(df_drop_header[0:10])
    df = df.drop(labels=df_drop_header, axis=1)
    dropped = True
    df.info()

# Print brief report of the cleaned data
logger.info('Shape of raw data: ({}, {})'.format(df.shape[0], n*m))
logger.info('Shape of cleaned data: {}'.format(df.shape))
logger.info('Total frame: {}'.format(time))
logger.info('N x M: {} x {}'.format(n, m))
logger.info('Max dits: {:.3f}'.format(bins[num_of_bin]))
logger.info('Min dist: {:.3f}'.format(bins[0]))
logger.info(df.columns)


# Write the distribution (histogram) to file
# This step may take some time depending on the dataset size
hist_data = []
outfile = open('{}/hist.csv'.format(outdir), 'w')
outfile.write('pair')
for i in range(1, num_of_bin + 1):
    outfile.write(',bin{}'.format(i))
outfile.write('\n')
for column in df:
    pair = df[column].values
    freq, bins = np.histogram(pair, bins)
    temp = freq.tolist()
    temp.insert(0, column)
    hist_data.append(temp)

# plot the heat map using unsorted hist data
heatmap('unsorted', hist_data, num_of_bin, time, bins_labels, outdir)

# Sort the distribution by bin and
bin = 1
hist_data.sort(key=lambda item: (-item[bin], -item[bin+1], -item[bin+2], -item[bin+3], -item[bin+4]))
logger.debug(hist_data[0:10])

# Plot the heat map using sorted hist data
heatmap('sorted', hist_data, num_of_bin, time, bins_labels, outdir)

# Write the sorted list to file
writer = csv.writer(outfile)
writer.writerows(hist_data)
outfile.close()

# Example: Plot the histogram
formatter = FuncFormatter(to_percent)
pair = df[hist_data[0][0]]
plt.hist(pair, bins=bins, ec='black', alpha=0.5, color='lightblue')
plt.gca().yaxis.set_major_formatter(formatter)
plt.xlim(0, bins[num_of_bin]+.5)
plt.ylim(0, hist_data[0][1] + time * 0.1)
plt.yticks(np.arange(0, hist_data[0][1] + time * 0.1, time/10))
rects = plt.gca().patches
bin_labels = ['Bin%d' % i for i in range(len(rects))]
for rect, bin_label in zip(rects, bin_labels):
    height = rect.get_height()
    if (height > 0):
        plt.gca().text(rect.get_x() + rect.get_width() / 2, height, bin_label, ha='center', va='bottom')


# Extract the top k
top_k = hist_data[0:k]
logger.debug(top_k)

top_k_label = [row[0] for row in top_k]
logger.debug(top_k_label)
top_k_data = [df[i].values for i in top_k_label]

# Plotting the overall top k
plot_top_k(time, top_k, df, bins, num_of_bin, hist_data, formatter, outdir, 'overall')


# subcommand: query by label
if args.subparser == 'query':
    query = args.label
    r_max = args.rmax
    s_max = args.smax
    percent_min = args.threshold

    distpair_of_interest = []
    total_interest = 0

    query_by_labels(query)

    # Extract distpair of interest from hist_data
    for item in hist_data:
        index_r = item[0].index('r')
        index_s = item[0].index('s')
        percent = item[1] / time
        if int(item[0][index_r+1:index_s]) <= r_max and int(item[0][index_s+1:]) <= s_max:
            total_interest += 1
            if  percent >= percent_min:
                distpair_of_interest.append(item)
                print(item)

    # print a report
    print('=====================')
    print('{} out of total {}'.format(len(distpair_of_interest), len(hist_data)))
    print('{} out of interest {}'.format(len(distpair_of_interest), total_interest))


    # Plotting the top k interested distpair
    plot_top_k(time, distpair_of_interest, df, bins, num_of_bin, hist_data, formatter, outdir, 'interest')
